{:title "Twenty-One Programming Languages in Twenty-One Years"
:layout :post
:tags  ["programming"]}

<img src="http://www.szcz.org/img/plwc.png" width="225px" alt="wordcloud"/>

The date of this post -- January 1, 2021 -- marks twenty-one years since I first became a professional software programmer.  By a happy coincidence, the number of programming languages I've worked on and learned in my life also comes to twenty-one.  I've listed them below in alphabetical order, along with some remarks on my current thoughts about each language.

1. **BASIC**.  First in the list alphabetically is the very first programming language I ever learned.  I took two classes in BASIC, one in the summer before I started 7th grade in a summer course at Grand Rapids Junior College, and second in high school as it was the language we learned in my high school programming class.  In high school, it blew my mind to consider that there were programming languages that didn't use line numbers for program flow; now it blows my mind to remember that I once thought in such a way.  I never had occasion to work on the language professionally, and doubtful I ever will.

2. **C**.  Like BASIC, I learned and worked on C in my undergraduate and graduate studies, but I never had occasion to work with the language professionally.  When I was most active with the language, I found using the language frustrating because I couldn't get a full grasp on its explicit non-automated memory management.  It has been a while (decades, really) since I last worked with C, and I wonder if I would fare better now with the language.

3. **Classic ASP**.  I had the ignominy of dealing with this wretched excuse of a programming language during its sunset years when I had to work with some websites that needed some updates and were never upgraded.  Easy to learn, easy to abuse, and thoroughly annoying and unsatisfying.

4. **Clojure**.  Easily my favorite programming language of all time.  Well-designed, elegant, useful, satisfying, fun, and full of useful tools.  I'm fortunate that I use it a lot at my job, it's my go-to language for most any default programming task, and it has made me an unabashed partisan of the paradigm of functional programming.  I can't speak highly enough about Clojure.

5. **Clojurescript**.  I suppose that my effusive praise for Clojure also extends to a great extent to Clojurescript given the overlap between the two languages.  But since that overlap isn't 100%, my praise for Clojurescript is reserved, but only slightly so.  There are features in Clojure that I wished Clojurescript had, but that's a mere quibble.  It's a solid language, and one in which I enjoy working with.

6. **C Shell**. I find it weird to include this, given the prominence of shell commands in any programmer's repertoire.  But I've written scripts in C Shell from time to time, so it gets an entry in this list.  The commands for C Shel are eminently useful, easy to learn, deep (I find myself still learning useful commands), but disparate and not unified.

7. **Elm**.  This gets my vote as my second-favorite programming language of all time.  The output is succinct, the code is well-organized and easy to write and to understand, development is a joy, and even when it doesn't work the compilation error messages are the best that I have _ever_ seen in a programming language.  I find myself using it more and more and I recommend this highly.

8. **Erlang**. I developed in Erlang for [just a single app](https://gist.github.com/msszczep/2460ff0098768b6e2c22f476aa1dd5f6) that had nothing to do with my professional life, but I found the experience rewarding and positively mind-stretching.  That said, despite the positive experience, I haven't had the yen to work with Erlang (or a related language, Elixir) to any great extent.  

9. **FORTRAN**.  This language was the focus of my first programming job for actual money.  For about four months, I updated FORTRAN code as a part-time job and at the time when I was working on it (in 1998), every time I mentioned I was working in FORTRAN, I constantly heard back a reply along the lines of "FORTRAN is still being used?"  FORTRAN comes up in conversation on rare occasions, and even made an appearance of sorts in the movie _Hidden Figures_.

10. **Haskell**.  I appreciate Haskell, especially given its close relationship to Elm (Elm is written in Haskell, and borrows much of its syntax from Haskell).  I don't have a lot of experience with Haskell, I don't have a particular Haskell-inspired itch to scratch, and I'm haltingly going through the [Haskell Book](https://haskellbook.com), but I do regard the language with high esteem.

11. **Java**.  I coded in Java a fair amount in graduate school, but it never came up as an option to code at work.  That, and my opinion of Java as being a bloated and overwrought language, meant I seriously thought I would never return to the language under any circumstance.  My love-affair with Clojure (which compiles to Java byte code; the "J" in Clo_j_ure refers to the Java virtual machine) proved me wrong.  I still don't expect to code in Java anytime soon, but I do follow Java developments just given my interest in Clojure.

12. **Javascript**.  A disliked necessity.  It's astonishing that a programming language so [haphazardly designed](https://whydoesitsuck.com/why-does-javascript-suck/) ranks arguably as the most popular programming language in the world.  I've coded it in the raw on occasion or with a helpful intermediary like JQuery, though these days I tend to compile it from Clojurescript or Elm.

13. **JSP**.  I learned just enough JSP to update an app written in JSP at a previous job.  Unremarkable, meh.  If I worked at it longer, I suppose my feelings about it would be stronger.

14. **LISP**.  In graduate school, I took a course on the [Structure and Interpretation of Computer Programs](https://mitpress.mit.edu/sites/default/files/sicp/index.html).  I learned LISP in the course, though at the time not without much joy -- my main complaint about it at the time was all the parentheses made it hard to parse (which led to the joke that LISP stood for Lots of Insignificant Stupid Parentheses).  Clojure, and modern enhancements to LISP-like languages (e.g., rainbow parens), addressed that problem, and I regard LISP in higher regard than when I did when I was a student, though if it weren't for my time spent with it as a student I wouldn't have an appreciation for it, and languages like it, today.

15. **Mathematica/Wolfram**. I'm like a kid at a candy store whenever I work with Mathematica (or its rebranded name, the [Wolfram Language](https://reference.wolfram.com/language/)).  It's staggering in its scope and number of functions, yet elegant in the way it's built and organized.  With its massive size, growing all the time, you're probably a few commands away from a nice solution.  [I've even contributed to the Wolfram Tweet-a-Program](https://pinboard.in/u:msszczep/tweets/search/?query=wolframtap).

16. **Pascal**.  My very first computer programming course in college was taught in Pascal.  I haven't used the language since, though I had a bit of exposure to Turbo Pascal many years later at one of my jobs.

17. **Perl**.  I used to be a _big_ Perl user: I used it at work, I used it at home, it was my go-to programming language for years.  Then, for some reason, I just dropped it utterly from my life.  The only time I use it now is from the command-line to adjust line endings for certain text files, maybe once or twice a year if that. (Joke I heard in grad-school: You know the joke about Perl, that it's a write-only language?)

18. **PHP**.  As with Perl, PHP was a big language in my life for many years: I used it at work and at home a ton.  But while Perl's disappearance from my life was a mystery, PHP disappearance from my life wasn't.  I recall vividly when one of my colleagues at work went on an epic rant against PHP, listing complaint after specific complaint against the language.  I haven't done much development with it since, and I've been steadily removing PHP from my life where possible.

19. **Python**.  I still use Python from time to time, but it's now nowhere near where the dominant role it played in my work and my life.  I now use when I feel I _need_ it rather than as something I _want_, but as programming languages with objects have fallen out of my life, even if they're not OO, Python's role in my life has subsequently diminished.  The Python code I write now is heavily colored by my present love of functional programming.

20. **React**.  I've coded in React on relatively rare occasions for work; I personally prefer to avoid it.  React is hot stuff at this writing, but my read of it is that it's prone to bloat and inefficiencies and I wonder if it'll go the way of PHP and Perl, where it'll eventually become a joke.

21. **Ruby**.  When I first interacted with Ruby, I thought it was incredible.  However, I've found myself thrown into Ruby update and upgrade tasks on an as-needed basis for old apps on their last legs.  (Overwhelmingly, my interactions with Ruby have nearly always been through Rails.)  This isn't exactly a combination to win you over.  In my estimation, Ruby (by which I mean Rails) suffers from bloat and the fact that you need to keep up with updates _a lot_, lest you fall further and further behind and the struggle to catch up doesn't warrant the time and effort involved.
